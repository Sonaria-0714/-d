<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>SONALIA: HIGH-END VISUALIZER</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }

        /* UI OVERLAY */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        #hud-header {
            position: absolute; top: 40px; left: 40px;
            border-left: 4px solid #00ffff; padding-left: 20px;
            background: linear-gradient(90deg, rgba(0,20,30,0.8), transparent);
        }
        h1 { margin: 0; font-size: 32px; color: #fff; text-shadow: 0 0 20px #00ffff; letter-spacing: 4px; }
        p { margin: 5px 0 0; color: #00ffff; font-size: 12px; letter-spacing: 2px; }

        /* C:F SLIDER CONTROL */
        #control-box {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            width: 400px; text-align: center; pointer-events: auto;
            background: rgba(0, 10, 20, 0.8); padding: 20px; border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }
        .slider-label { display: flex; justify-content: space-between; color: #fff; font-size: 12px; margin-bottom: 10px; font-weight: bold; }
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%;
            background: #fff; cursor: pointer; margin-top: -8px; box-shadow: 0 0 10px #fff;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer;
            background: linear-gradient(90deg, #00ffff, #ff0055); border-radius: 2px;
        }
        .status-text { margin-top: 10px; color: #00ffff; font-family: monospace; font-size: 12px; }

        /* LOADER */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1s;
        }
        .load-text { font-size: 40px; color: #fff; font-weight: bold; letter-spacing: 5px; text-shadow: 0 0 20px #00ffff; }
        .load-sub { color: #00ffff; margin-top: 10px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>

    <script src="https://unpkg.com/three@0.124.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.124.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.124.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.124.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.124.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.124.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.124.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.124.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="loader">
        <div class="load-text">SONALIA</div>
        <div class="load-sub">LOADING HIGH-SPEC VISUALIZER...</div>
    </div>

    <div id="ui-layer">
        <div id="hud-header">
            <h1>人体構造モデル</h1>
            <p>High-End Visualization w/ Bloom Effect</p>
        </div>
        
        <div id="control-box">
            <div class="slider-label">
                <span style="color:#00ffff">COGNITION (思考)</span>
                <span style="color:#ff0055">FEELING (感情)</span>
            </div>
            <input type="range" id="cf-slider" min="0" max="100" value="50">
            <div class="status-text" id="cf-status">BALANCE: NEUTRAL</div>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const CONFIG = {
            particleCount: 2500, // 人体を構成する粒子の数
            flowSpeed: 2.0,
            baseColor: new THREE.Color(0x00ffff), // C (Cognition)
            altColor: new THREE.Color(0xff0055)   // F (Feeling)
        };

        let scene, camera, renderer, composer, controls;
        let humanPoints, osGroup, flowSystem;
        let cfRatio = 0.5; // 0.0(C) ~ 1.0(F)

        function init() {
            // 1. Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 3000);
            camera.position.set(0, 20, 350);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // リアルな光の処理
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            // 4. Post-processing (Bloom Effect)
            const renderScene = new THREE.RenderPass(scene, camera);
            // Resolution, Strength, Radius, Threshold
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.2; // 発光強度
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 5. Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // --- OBJECTS ---
            buildParticleHuman();
            buildOSLayers();
            buildNeuralFlow();
            buildEnvironment();

            // Event Listeners
            window.addEventListener('resize', onResize);
            document.getElementById('cf-slider').addEventListener('input', onSliderChange);

            // Start Loop
            animate();
            
            // Hide Loader
            setTimeout(() => {
                const l = document.getElementById('loader');
                l.style.opacity = 0;
                setTimeout(()=>l.style.display='none', 1000);
            }, 2000);
        }

        // --- 1. HUMAN BODY (Particle System) ---
        function buildParticleHuman() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color();

            for (let i = 0; i < CONFIG.particleCount; i++) {
                // Human Shape Logic
                const y = (Math.random() * 260) - 130; 
                let rMax = 0;
                
                if (y > 100) rMax = 22; // Head
                else if (y > 80) rMax = 12; // Neck
                else if (y > 10) rMax = 50; // Chest
                else if (y > -50) rMax = 40; // Waist
                else rMax = 45; // Legs

                const angle = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * rMax; // Uniform distribution
                
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                positions.push(x, y, z);

                // Initial Color (Cyan)
                color.setHSL(0.5, 1.0, 0.5 + Math.random()*0.5);
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 2.0,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            humanPoints = new THREE.Points(geometry, material);
            scene.add(humanPoints);
        }

        // --- 2. OS LAYERS (Rings) ---
        function buildOSLayers() {
            osGroup = new THREE.Group();
            scene.add(osGroup);

            const layers = [
                { y: 40, col: 0x00ffff }, // 生存
                { y: 55, col: 0x3388ff }, // 評価
                { y: 70, col: 0xaa00ff }, // 報酬
                { y: 85, col: 0xffd700 }  // 時間
            ];

            layers.forEach(l => {
                const geo = new THREE.TorusGeometry(35, 0.3, 16, 100);
                const mat = new THREE.MeshBasicMaterial({ color: l.col });
                const ring = new THREE.Mesh(geo, mat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = l.y;
                osGroup.add(ring);

                // Energy Field
                const plane = new THREE.Mesh(
                    new THREE.CircleGeometry(30, 32),
                    new THREE.MeshBasicMaterial({ color: l.col, transparent: true, opacity: 0.05, side: THREE.DoubleSide })
                );
                plane.rotation.x = Math.PI / 2;
                plane.position.y = l.y;
                osGroup.add(plane);
            });
        }

        // --- 3. NEURAL FLOW (Traffic) ---
        function buildNeuralFlow() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            // Flow particles count
            for(let i=0; i<200; i++) {
                positions.push(0, 0, 0); // Init
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 3.0,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            flowSystem = new THREE.Points(geometry, material);
            // Store animation state in userData
            flowSystem.userData = {
                particles: Array(200).fill().map(() => ({
                    y: 140 + Math.random()*50,
                    speed: 1 + Math.random()*2,
                    offset: Math.random() * Math.PI * 2,
                    radius: 0
                }))
            };
            scene.add(flowSystem);
        }

        // --- 4. ENVIRONMENT ---
        function buildEnvironment() {
            // Grid Floor
            const grid = new THREE.GridHelper(1000, 40, 0x111111, 0x050505);
            grid.position.y = -150;
            scene.add(grid);
        }

        // --- ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const time = Date.now() * 0.001;

            // 1. Human Pulse
            const beat = 1 + Math.sin(time * (2 + cfRatio*5)) * 0.01; // Emotion increases heart rate
            humanPoints.scale.set(beat, beat, beat);

            // 2. Color Update based on C:F Balance
            updateColors();

            // 3. Flow Animation
            const positions = flowSystem.geometry.attributes.position.array;
            const pData = flowSystem.userData.particles;

            for(let i=0; i<pData.length; i++) {
                const p = pData[i];
                p.y -= p.speed * (1 + cfRatio); // Emotion speeds up flow
                
                // Spiral path
                const r = 5 + Math.sin(time*5 + p.offset)*15 * cfRatio; // Emotion makes chaotic
                const x = Math.cos(time*3 + p.offset) * r;
                const z = Math.sin(time*3 + p.offset) * r;

                if (p.y < -130) p.y = 140; // Reset

                positions[i*3] = x;
                positions[i*3+1] = p.y;
                positions[i*3+2] = z;
            }
            flowSystem.geometry.attributes.position.needsUpdate = true;

            // Bloom Render
            composer.render();
        }

        // --- INTERACTION ---
        function onSliderChange(e) {
            const val = e.target.value;
            cfRatio = val / 100; // 0.0 to 1.0
            
            const status = document.getElementById('cf-status');
            if(cfRatio < 0.4) status.innerText = "MODE: LOGICAL ANALYSIS (思考優位)";
            else if(cfRatio > 0.6) status.innerText = "MODE: EMOTIONAL DRIVE (感情優位)";
            else status.innerText = "MODE: BALANCED (バランス)";
            
            status.style.color = cfRatio > 0.5 ? '#ff0055' : '#00ffff';
        }

        function updateColors() {
            const colors = humanPoints.geometry.attributes.color.array;
            const targetColor = new THREE.Color().lerpColors(CONFIG.baseColor, CONFIG.altColor, cfRatio);
            
            // update all particles slightly
            for(let i=0; i<CONFIG.particleCount; i++) {
                // Add some noise
                const noise = Math.random()*0.2;
                colors[i*3] = targetColor.r + noise;
                colors[i*3+1] = targetColor.g + noise;
                colors[i*3+2] = targetColor.b + noise;
            }
            humanPoints.geometry.attributes.color.needsUpdate = true;
            
            // Update Flow Color
            flowSystem.material.color.lerpColors(new THREE.Color(0xffffff), CONFIG.altColor, cfRatio * 0.5);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // START
        window.onload = init;

    </script>
</body>
</html>
