<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SONALIA: PURE CORE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }

        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        #hud-title {
            position: absolute; top: 40px; left: 40px;
            border-left: 4px solid #00ffff; padding-left: 20px;
            background: linear-gradient(90deg, rgba(0,20,30,0.8), transparent);
        }
        h1 { margin: 0; font-size: 32px; color: #fff; text-shadow: 0 0 20px #00ffff; letter-spacing: 4px; }
        p { margin: 5px 0 0; color: #00ffff; font-size: 14px; letter-spacing: 2px; }

        /* C:F METER */
        #cf-container {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 400px; text-align: center; pointer-events: auto;
        }
        .cf-bar-bg {
            width: 100%; height: 8px; background: #222; border: 1px solid #555; border-radius: 4px;
            position: relative; margin-top: 10px; box-shadow: 0 0 15px rgba(0,255,255,0.2); cursor: pointer;
        }
        .cf-fill {
            position: absolute; top: 0; left: 0; height: 100%; width: 50%;
            background: linear-gradient(90deg, #00ffff, #ff0055); opacity: 0.5;
        }
        .cf-knob {
            width: 16px; height: 16px; background: #fff; border-radius: 50%; 
            position: absolute; top: -4px; left: 50%; transform: translateX(-50%);
            box-shadow: 0 0 10px #fff; transition: left 0.1s;
        }
        .cf-labels { display: flex; justify-content: space-between; font-size: 12px; color: #88aaff; font-weight: bold; }

        /* PANEL */
        #panel {
            position: absolute; top: 0; right: 0; width: 380px; height: 100%;
            background: rgba(8, 12, 16, 0.96); border-left: 1px solid #333;
            transform: translateX(100%); transition: 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            color: #eee; display: flex; flex-direction: column; z-index: 20; pointer-events: auto;
        }
        #panel.active { transform: translateX(0); }
        .p-head { padding: 40px 30px; border-bottom: 1px solid #333; background: linear-gradient(180deg, rgba(0,255,255,0.1), transparent); }
        .p-tag { font-size: 10px; padding: 3px 8px; border-radius: 2px; background: #00ffff; color: #000; font-weight: bold; }
        .p-title { font-size: 28px; margin: 15px 0 0; color: #fff; text-shadow: 0 0 15px currentColor; }
        .p-body { padding: 30px; overflow-y: auto; flex: 1; }
        .row { margin-bottom: 30px; }
        .label { font-size: 11px; color: #00ffff; border-bottom: 1px solid rgba(255,255,255,0.2); display: block; margin-bottom: 8px; letter-spacing: 1px; }
        .text { font-size: 14px; line-height: 1.7; color: #ccc; }
        .thought { font-family: monospace; color: #fff; background: rgba(0,255,255,0.05); padding: 15px; border-left: 3px solid #00ffff; }
        .close-btn { position: absolute; top: 20px; right: 20px; font-size: 24px; cursor: pointer; color: #777; }
        .close-btn:hover { color: #fff; }

        /* LOADER */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s; cursor: pointer;
        }
        .load-text { font-size: 40px; color: #fff; font-weight: bold; letter-spacing: 6px; text-shadow: 0 0 30px #00ffff; }
        .load-sub { color: #00ffff; font-family: monospace; margin-top: 15px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

    <div id="loader" onclick="startApp()">
        <div class="load-text">SONALIA</div>
        <div class="load-sub">LOADING PURE CORE...</div>
    </div>

    <div id="ui-layer">
        <div id="hud-title">
            <h1>思考回路マップ</h1>
            <p>4D LOGIC PIPELINE</p>
        </div>
        <div id="cf-container">
            <div class="cf-labels"><span>COGNITION</span><span>FEELING</span></div>
            <div class="cf-bar-bg" id="cf-track">
                <div class="cf-fill" id="cf-fill"></div>
                <div class="cf-knob" id="cf-knob"></div>
            </div>
        </div>
    </div>

    <div id="panel">
        <div class="close-btn" onclick="closePanel()">×</div>
        <div class="p-head">
            <span class="p-tag" id="p-tag">TAG</span>
            <h2 class="p-title" id="p-title">Title</h2>
        </div>
        <div class="p-body">
            <div class="row"><span class="label">DEFINITION</span><div class="text" id="p-desc">...</div></div>
            <div class="row"><span class="label">SYSTEM ROLE</span><div class="text" id="p-role">...</div></div>
            <div class="row"><span class="label">INTERNAL VOICE</span><div class="thought" id="p-thought">...</div></div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // --- DATA ---
        const NODES = [
            // Head
            { id:"IN", type:"INPUT", name:"五感入力", color:"#FFFFFF", x:0, y:0, z:-160, size:8, desc:"外界情報の取得。", role:"Input", thought:"(Sensing)" },
            // Chest
            { id:"OS4", type:"OS", name:"時間/協調", color:"#FFD700", x:0, y:0, z:-110, size:6, desc:"大局的判断。", role:"Meta View", thought:"「将来は？」" },
            { id:"OS3", type:"OS", name:"報酬/意味", color:"#AA00FF", x:0, y:0, z:-90, size:6, desc:"価値判断。", role:"Value", thought:"「意味ある？」" },
            { id:"OS2", type:"OS", name:"評価/所属", color:"#3388FF", x:0, y:0, z:-70, size:6, desc:"社会的判断。", role:"Social", thought:"「正しい？」" },
            { id:"OS1", type:"OS", name:"生存/生活", color:"#00FFFF", x:0, y:0, z:-50, size:6, desc:"生存本能。", role:"Survival", thought:"「安全？」" },
            // Stomach
            { id:"DB1", type:"DB", name:"欲求DB", color:"#FF5500", x:-25, y:25, z:10, size:10, desc:"根源的渇望。", role:"Motivation", thought:"(Desire)" },
            { id:"DB2", type:"DB", name:"情動DB", color:"#0044FF", x:25, y:25, z:10, size:10, desc:"感情記憶。", role:"Emotion", thought:"(Feeling)" },
            { id:"DB3", type:"DB", name:"価値観DB", color:"#FFCC00", x:25, y:-25, z:10, size:10, desc:"信念体系。", role:"Belief", thought:"(Rule)" },
            { id:"DB4", type:"DB", name:"無意識DB", color:"#888888", x:-25, y:-25, z:10, size:10, desc:"自動反応。", role:"Reflex", thought:"(Habit)" },
            // Waist (Factors)
            { id:"IQ", type:"係数", name:"IQ", color:"#00CCFF", z:70, angle:0, size:7, desc:"論理力。", role:"Logic", thought:"分析" },
            { id:"EQ", type:"係数", name:"EQ", color:"#FF6666", z:70, angle:1, size:7, desc:"感情力。", role:"Empathy", thought:"共感" },
            { id:"SQ", type:"係数", name:"SQ", color:"#FFCC00", z:70, angle:2, size:7, desc:"社会性。", role:"Social", thought:"適応" },
            { id:"AQ", type:"係数", name:"AQ", color:"#888888", z:70, angle:3, size:7, desc:"逆境力。", role:"Resilience", thought:"忍耐" },
            { id:"CQ", type:"係数", name:"CQ", color:"#AA00FF", z:70, angle:4, size:7, desc:"創造力。", role:"Idea", thought:"発想" },
            { id:"HQ", type:"係数", name:"HQ", color:"#FFFFFF", z:70, angle:5, size:7, desc:"人間力。", role:"Ethics", thought:"誠実" },
            { id:"MQ", type:"係数", name:"MQ", color:"#FF3300", z:70, angle:6, size:7, desc:"行動力。", role:"Action", thought:"実行" },
            { id:"KQ", type:"係数", name:"KQ", color:"#00FF88", z:70, angle:7, size:7, desc:"知識力。", role:"Knowledge", thought:"応用" },
            // Output
            { id:"OUT", type:"OUTPUT", name:"行動", color:"#FFFFFF", x:0, y:0, z:160, size:10, desc:"最終出力。", role:"Output", thought:"(Act)" }
        ];

        // --- ENGINE (Pure Canvas 3D) ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let points = [];
        let particles = [];
        let stars = [];
        
        // Camera
        let angleX = 0; // Vertical rot
        let angleY = -1.5; // Horizontal rot (Start sideways)
        let cfRatio = 0.5;
        
        let mouseX = 0, mouseY = 0;
        let isDragging = false;
        let lastMouseX = 0;

        // 3D Point Class
        class Point3D {
            constructor(d) {
                this.x = d.x || 0; this.y = d.y || 0; this.z = d.z || 0;
                if(d.angle !== undefined) {
                    const r = 60;
                    const ang = (d.angle / 8) * Math.PI * 2;
                    this.x = Math.cos(ang) * r;
                    this.y = Math.sin(ang) * r;
                }
                this.color = d.color;
                this.size = d.size;
                this.data = d;
                this.sx=0; this.sy=0; this.scale=0; this.depth=0;
            }
            project(cx, cy) {
                // Rotation Order: Y then X
                // 1. Rotate Y
                let x1 = this.x * Math.cos(angleY) - this.z * Math.sin(angleY);
                let z1 = this.z * Math.cos(angleY) + this.x * Math.sin(angleY);
                let y1 = this.y;
                
                // 2. Rotate X (Tilt) - Fixed tilt for view
                const tilt = 0.2; 
                let y2 = y1 * Math.cos(tilt) - z1 * Math.sin(tilt);
                let z2 = z1 * Math.cos(tilt) + y1 * Math.sin(tilt);
                
                // 3. Project (Z is depth, mapped to screen X for horizontal flow)
                // For sleeper view: Z-axis is horizontal.
                // We want Z to go Left(-160) to Right(160).
                // Screen X = z2, Screen Y = x1
                // Standard Projection:
                // x -> x, y -> y, z -> depth
                
                // Let's just use standard projection and rely on camera rotation
                const fov = 600;
                const scale = fov / (fov + z2 + 400);
                this.sx = x1 * scale + cx;
                this.sy = y2 * scale + cy;
                this.scale = scale;
                this.depth = z2;
            }
            draw(ctx) {
                const r = this.size * this.scale;
                // Glow
                const g = ctx.createRadialGradient(this.sx, this.sy, 0, this.sx, this.sy, r*4);
                g.addColorStop(0, this.color);
                g.addColorStop(1, "rgba(0,0,0,0)");
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(this.sx, this.sy, r*4, 0, Math.PI*2); ctx.fill();
                // Core
                ctx.fillStyle = "#fff";
                ctx.beginPath(); ctx.arc(this.sx, this.sy, r, 0, Math.PI*2); ctx.fill();
                
                // Ring for OS
                if(this.data.type.includes("OS")) {
                    ctx.strokeStyle = `rgba(255,255,255,0.3)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(this.sx, this.sy, 35*this.scale, 35*this.scale, 0, 0, Math.PI*2);
                    ctx.stroke();
                }
                // Ring for Factor
                if(this.data.type === "係数") {
                    // Draw Orbit Ring (Static approximation)
                    // Actually complex in 2D without full 3D line projection
                }

                // Label
                if(this.scale > 0.6) {
                    ctx.fillStyle="#fff"; ctx.font = (10*this.scale)+"px Arial"; ctx.textAlign="center";
                    ctx.fillText(this.data.name, this.sx, this.sy+r+12);
                }
            }
        }

        function init() {
            resize();
            points = NODES.map(d => new Point3D(d));
            
            // Stars
            for(let i=0; i<100; i++) {
                stars.push({
                    x: (Math.random()-0.5)*1000, y: (Math.random()-0.5)*600, z: (Math.random()-0.5)*1000
                });
            }
            
            // Flow Particles
            for(let i=0; i<80; i++) {
                particles.push({
                    z: -200, speed: 2+Math.random()*3, offset: Math.random()*Math.PI*2
                });
            }
            
            loop();
            setTimeout(startApp, 500);
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        // --- LOOP ---
        function loop() {
            // Clear
            ctx.fillStyle = "#000005";
            ctx.fillRect(0, 0, width, height);
            
            const cx = width/2;
            const cy = height/2;
            const time = Date.now() * 0.001;

            // Auto Rotate
            if(!isDragging) angleY += 0.002;

            // 1. Project Points
            points.forEach(p => p.project(cx, cy, 500));
            points.sort((a,b) => b.depth - a.depth);

            // 2. Draw Stars
            ctx.fillStyle = "#555";
            stars.forEach(s => {
                // Simple projection
                let x = s.x * Math.cos(angleY) - s.z * Math.sin(angleY);
                let z = s.z * Math.cos(angleY) + s.x * Math.sin(angleY);
                let scale = 500 / (500 + z + 400);
                let sx = x * scale + cx;
                let sy = s.y * scale + cy;
                if(scale > 0) ctx.fillRect(sx, sy, scale, scale);
            });

            // 3. Draw Spine Line (Connecting center points)
            const spineStart = {x:0, y:0, z:-180};
            const spineEnd = {x:0, y:0, z:160};
            
            function proj(v) {
                let x = v.x * Math.cos(angleY) - v.z * Math.sin(angleY);
                let z = v.z * Math.cos(angleY) + v.x * Math.sin(angleY);
                let y = v.y * Math.cos(0.2) - z * Math.sin(0.2);
                z = z * Math.cos(0.2) + v.y * Math.sin(0.2);
                let s = 500/(500+z+400);
                return {x: x*s+cx, y: y*s+cy};
            }
            
            const ss = proj(spineStart);
            const se = proj(spineEnd);
            ctx.strokeStyle = "rgba(0, 255, 255, 0.2)";
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(ss.x, ss.y); ctx.lineTo(se.x, se.y); ctx.stroke();

            // 4. Draw Particles (Flow)
            particles.forEach(p => {
                p.z += p.speed * (1 + (cfRatio-0.5));
                if(p.z > 160) p.z = -200;
                
                // Spiral
                let r = 10;
                if(p.z > -20 && p.z < 20) r = 25; // Expand at DB
                
                let px = Math.cos(time*5 + p.offset) * r;
                let py = Math.sin(time*5 + p.offset) * r;
                
                let pt = proj({x:px, y:py, z:p.z});
                
                // Color mix
                let rCol = 255 * cfRatio;
                let bCol = 255 * (1-cfRatio);
                ctx.fillStyle = `rgb(${rCol}, 255, ${bCol})`;
                
                ctx.beginPath(); ctx.arc(pt.x, pt.y, 3, 0, Math.PI*2); ctx.fill();
            });

            // 5. Draw Nodes & Connections
            ctx.lineWidth = 1;
            points.forEach(p => {
                // Line to spine
                let sp = proj({x:0, y:0, z:p.data.z});
                ctx.strokeStyle = "rgba(255,255,255,0.1)";
                ctx.beginPath(); ctx.moveTo(sp.x, sp.y); ctx.lineTo(p.sx, p.sy); ctx.stroke();
                
                p.draw(ctx);
            });

            requestAnimationFrame(loop);
        }

        // --- INTERACTION ---
        window.addEventListener('resize', resize);
        
        window.addEventListener('mousedown', e => {
            if(e.target.closest('#panel') || e.target.closest('#cf-container')) return;
            isDragging = true;
            lastMouseX = e.clientX;
            
            // Hit Test
            const sorted = [...points].sort((a,b) => a.depth - b.depth); // Front first
            let hit = false;
            for(let p of sorted) {
                let dx = e.clientX - p.sx;
                let dy = e.clientY - p.sy;
                if(Math.sqrt(dx*dx + dy*dy) < 20 * p.scale) {
                    showPanel(p.data);
                    hit = true;
                    isDragging = false;
                    break;
                }
            }
            if(!hit) closePanel();
        });
        
        window.addEventListener('mousemove', e => {
            if(isDragging) {
                let delta = e.clientX - lastMouseX;
                angleY += delta * 0.005;
                lastMouseX = e.clientX;
            }
            // Cursor
            let hit = false;
            for(let p of points) {
                let dx = e.clientX - p.sx;
                let dy = e.clientY - p.sy;
                if(Math.sqrt(dx*dx + dy*dy) < 20 * p.scale) hit = true;
            }
            document.body.style.cursor = hit ? 'pointer' : 'default';
        });
        window.addEventListener('mouseup', () => isDragging = false);

        // Slider
        const track = document.getElementById('cf-track');
        const knob = document.getElementById('cf-knob');
        const fill = document.getElementById('cf-fill');
        
        track.addEventListener('mousedown', e => {
            const rect = track.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let pct = Math.max(0, Math.min(1, x / rect.width));
            cfRatio = pct;
            knob.style.left = (pct * 100) + '%';
            fill.style.width = (pct * 100) + '%';
        });

        function showPanel(d) {
            document.getElementById('p-tag').innerText = d.type;
            document.getElementById('p-tag').style.background = d.color;
            document.getElementById('p-title').innerText = d.name;
            document.getElementById('p-title').style.color = d.color;
            document.getElementById('p-desc').innerText = d.desc;
            document.getElementById('p-role').innerText = d.role;
            document.getElementById('p-thought').innerText = d.thought;
            document.getElementById('panel').classList.add('active');
        }
        function closePanel() { document.getElementById('panel').classList.remove('active'); }
        window.closePanel = closePanel;

        function startApp() {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => { document.getElementById('loader').style.display='none'; }, 500);
        }
        window.startApp = startApp;

        // Start
        init();

    </script>
</body>
</html>
