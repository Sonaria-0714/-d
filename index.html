<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SONALIA: LOGICAL PIPELINE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }

        /* --- UI LAYER --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        #hud-title {
            position: absolute; top: 40px; left: 40px;
            border-left: 4px solid #00ffff; padding-left: 20px;
            background: linear-gradient(90deg, rgba(0,20,30,0.9), transparent);
        }
        h1 { margin: 0; font-size: 32px; color: #fff; text-shadow: 0 0 20px #00ffff; letter-spacing: 4px; }
        p { margin: 5px 0 0; color: #00ffff; font-size: 14px; letter-spacing: 2px; }

        /* C:F METER */
        #cf-container {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 500px; text-align: center; pointer-events: auto;
        }
        .cf-bar-bg {
            width: 100%; height: 8px; background: #222; border: 1px solid #555; border-radius: 4px;
            position: relative; margin-top: 10px; box-shadow: 0 0 15px rgba(0,255,255,0.1);
            cursor: pointer;
        }
        .cf-knob {
            width: 16px; height: 24px; background: #fff; position: absolute; top: -8px; left: 50%;
            transform: translateX(-50%); box-shadow: 0 0 10px #fff; transition: left 0.1s;
            border-radius: 4px;
        }
        .cf-labels { display: flex; justify-content: space-between; font-size: 12px; color: #88aaff; font-weight: bold; }

        /* INFO PANEL */
        #panel {
            position: absolute; top: 0; right: 0; width: 380px; height: 100%;
            background: rgba(8, 12, 16, 0.96); border-left: 1px solid #333;
            transform: translateX(100%); transition: 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            color: #eee; display: flex; flex-direction: column; z-index: 20; pointer-events: auto;
            backdrop-filter: blur(10px);
        }
        #panel.active { transform: translateX(0); }
        .p-head { padding: 40px 30px; border-bottom: 1px solid #333; background: linear-gradient(180deg, rgba(0,255,255,0.1), transparent); }
        .p-tag { font-size: 10px; padding: 4px 10px; border-radius: 2px; background: #00ffff; color: #000; font-weight: 800; }
        .p-title { font-size: 28px; margin: 15px 0 0; color: #fff; text-shadow: 0 0 15px currentColor; }
        .p-body { padding: 30px; overflow-y: auto; flex: 1; }
        .row { margin-bottom: 30px; }
        .label { font-size: 11px; color: #00ffff; border-bottom: 1px solid rgba(255,255,255,0.2); display: block; margin-bottom: 8px; letter-spacing: 1px; }
        .text { font-size: 14px; line-height: 1.7; color: #ccc; }
        .thought { font-family: monospace; color: #fff; background: rgba(0,255,255,0.05); padding: 15px; border-left: 3px solid #00ffff; }
        .close-btn { position: absolute; top: 20px; right: 20px; font-size: 24px; cursor: pointer; color: #777; }
        .close-btn:hover { color: #fff; }

        /* LOADER */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s; cursor: pointer;
        }
        .load-text { font-size: 40px; color: #fff; font-weight: bold; letter-spacing: 6px; text-shadow: 0 0 30px #00ffff; }
        .load-sub { color: #00ffff; font-family: monospace; margin-top: 15px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

    <div id="loader" onclick="startApp()">
        <div class="load-text">SONALIA</div>
        <div class="load-sub">LOADING PIPELINE...</div>
    </div>

    <div id="ui-layer">
        <div id="hud-title">
            <h1>思考回路マップ</h1>
            <p>LOGIC PIPELINE VISUALIZER</p>
        </div>

        <div id="cf-container">
            <div class="cf-labels">
                <span>COGNITION (思考)</span>
                <span>FEELING (感情)</span>
            </div>
            <div class="cf-bar-bg" id="cf-track">
                <div class="cf-knob" id="cf-knob"></div>
            </div>
        </div>
    </div>

    <div id="panel">
        <div class="close-btn" onclick="closePanel()">×</div>
        <div class="p-head">
            <span class="p-tag" id="p-tag">TAG</span>
            <h2 class="p-title" id="p-title">Title</h2>
        </div>
        <div class="p-body">
            <div class="row"><span class="label">DEFINITION</span><div class="text" id="p-desc">...</div></div>
            <div class="row"><span class="label">SYSTEM ROLE</span><div class="text" id="p-role">...</div></div>
            <div class="row"><span class="label">INTERNAL VOICE</span><div class="thought" id="p-thought">...</div></div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // --- DATA DEFINITION ---
        const NODES = [
            // 1. INPUT (Head)
            { id:"IN", type:"INPUT", name:"五感入力", color:"#FFFFFF", x:0, y:-180, z:0, size:8, desc:"外界情報の取得。", role:"Input", thought:"(Sensing)" },
            
            // 2. OS (Chest Rings)
            { id:"OS4", type:"OS", name:"時間/協調", color:"#FFD700", x:0, y:-120, z:50, size:6, desc:"大局的判断。", role:"Meta View", thought:"「将来は？」" },
            { id:"OS3", type:"OS", name:"報酬/意味", color:"#AA00FF", x:0, y:-100, z:50, size:6, desc:"価値判断。", role:"Value", thought:"「意味ある？」" },
            { id:"OS2", type:"OS", name:"評価/所属", color:"#3388FF", x:0, y:-80, z:50, size:6, desc:"社会的判断。", role:"Social", thought:"「正しい？」" },
            { id:"OS1", type:"OS", name:"生存/生活", color:"#00FFFF", x:0, y:-60, z:50, size:6, desc:"生存本能。", role:"Survival", thought:"「安全？」" },

            // 3. DB (Stomach Core) - Offsets for visual clarity
            { id:"DB1", type:"DB", name:"欲求DB", color:"#FF5500", x:-30, y:-10, z:30, size:10, desc:"根源的渇望。", role:"Motivation", thought:"(Desire)" },
            { id:"DB2", type:"DB", name:"情動DB", color:"#0044FF", x:30, y:-10, z:30, size:10, desc:"感情記憶。", role:"Emotion", thought:"(Feeling)" },
            { id:"DB3", type:"DB", name:"価値観DB", color:"#FFCC00", x:30, y:-10, z:-30, size:10, desc:"信念体系。", role:"Belief", thought:"(Rule)" },
            { id:"DB4", type:"DB", name:"無意識DB", color:"#888888", x:-30, y:-10, z:-30, size:10, desc:"自動反応。", role:"Reflex", thought:"(Habit)" },

            // 4. FACTOR (Waist Ring)
            { id:"IQ", type:"係数", name:"IQ", color:"#00CCFF", y:60, angle:0, size:7, desc:"論理力。", role:"Logic", thought:"分析" },
            { id:"EQ", type:"係数", name:"EQ", color:"#FF6666", y:60, angle:1, size:7, desc:"感情力。", role:"Empathy", thought:"共感" },
            { id:"SQ", type:"係数", name:"SQ", color:"#FFCC00", y:60, angle:2, size:7, desc:"社会性。", role:"Social", thought:"適応" },
            { id:"AQ", type:"係数", name:"AQ", color:"#888888", y:60, angle:3, size:7, desc:"逆境力。", role:"Resilience", thought:"忍耐" },
            { id:"CQ", type:"係数", name:"CQ", color:"#AA00FF", y:60, angle:4, size:7, desc:"創造力。", role:"Idea", thought:"発想" },
            { id:"HQ", type:"係数", name:"HQ", color:"#FFFFFF", y:60, angle:5, size:7, desc:"人間力。", role:"Ethics", thought:"誠実" },
            { id:"MQ", type:"係数", name:"MQ", color:"#FF3300", y:60, angle:6, size:7, desc:"行動力。", role:"Action", thought:"実行" },
            { id:"KQ", type:"係数", name:"KQ", color:"#00FF88", y:60, angle:7, size:7, desc:"知識力。", role:"Knowledge", thought:"応用" },

            // 5. OUTPUT (Feet)
            { id:"OUT", type:"OUTPUT", name:"行動", color:"#FFFFFF", x:0, y:150, z:0, size:10, desc:"最終出力。", role:"Output", thought:"(Act)" }
        ];

        // Labels for diagram
        const LABELS = [
            { text: "◀ 入力 (五感)", y: -180 },
            { text: "◀ 4層OS (意味付)", y: -90 },
            { text: "◀ 内面DB (ルーツ)", y: -10 },
            { text: "◀ 8係数 (処理)", y: 60 },
            { text: "◀ 出力 (行動)", y: 150 }
        ];

        // --- 1. ENGINE ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let points = [];
        let flowParticles = [];
        
        // Camera
        let angleY = 0; 
        let cfRatio = 0.5; // 0 to 1
        let isDragging = false;
        let lastMouseX = 0;

        // Class Point
        class Point {
            constructor(d) {
                this.x = d.x || 0; this.y = d.y || 0; this.z = d.z || 0;
                // Factor arrange
                if(d.angle !== undefined) {
                    const r = 60;
                    const ang = (d.angle / 8) * Math.PI * 2;
                    this.x = Math.cos(ang) * r;
                    this.z = Math.sin(ang) * r;
                }
                this.color = d.color;
                this.size = d.size;
                this.data = d;
                this.sx=0; this.sy=0; this.scale=0;
            }
            project(cx, cy) {
                // Rotate Y
                let x = this.x * Math.cos(angleY) - this.z * Math.sin(angleY);
                let z = this.z * Math.cos(angleY) + this.x * Math.sin(angleY);
                let y = this.y;

                // Map Y to Screen X (Horizontal Layout)
                // Head(-180) -> Left, Feet(+150) -> Right
                let px = y; 
                let py = x; 
                let pz = z;

                const fov = 600;
                const scale = fov / (fov + pz + 400);
                this.sx = px * scale + cx;
                this.sy = py * scale + cy;
                this.scale = scale;
                this.zIndex = pz;
            }
            draw(ctx) {
                // Draw Connection Line (Spine/Nerve)
                // Connect to spine center (y axis)
                // Simplified visualization: Draw line to "Spine"
                // Not drawing here, drawn in batch
                
                // Draw Node
                ctx.globalAlpha = 1.0;
                const r = this.size * this.scale;
                
                // Glow
                const grad = ctx.createRadialGradient(this.sx, this.sy, 0, this.sx, this.sy, r*4);
                grad.addColorStop(0, this.color);
                grad.addColorStop(1, "rgba(0,0,0,0)");
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(this.sx, this.sy, r*4, 0, Math.PI*2); ctx.fill();

                // Core
                ctx.fillStyle = "#fff";
                ctx.beginPath(); ctx.arc(this.sx, this.sy, r, 0, Math.PI*2); ctx.fill();

                // Text
                if(this.scale > 0.6) {
                    ctx.fillStyle = "#fff";
                    ctx.font = (10 * this.scale) + "px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText(this.data.name, this.sx, this.sy + r + 15);
                }
            }
        }

        function init() {
            resize();
            points = NODES.map(d => new Point(d));
            
            // Create Flow Particles
            for(let i=0; i<60; i++) {
                flowParticles.push({
                    y: -200, // Start at Head
                    speed: 2 + Math.random()*3,
                    offset: Math.random() * Math.PI * 2,
                    phase: 0 // 0:Input, 1:OS, 2:DB, 3:Factor, 4:Out
                });
            }
            
            animate();
            setTimeout(startApp, 500);
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        function hexToRgb(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r},${g},${b},${alpha})`;
        }

        function animate() {
            // Clear
            ctx.fillStyle = "#000510";
            ctx.fillRect(0, 0, width, height);

            const cx = width / 2;
            const cy = height / 2;
            
            if(!isDragging) angleY += 0.003;

            // Project Points
            points.forEach(p => p.project(cx, cy));
            points.sort((a, b) => b.zIndex - a.zIndex);

            // 1. Draw Central Spine (Pipeline)
            const spineStart = { x: 0, y: -200, z: 0 };
            const spineEnd = { x: 0, y: 180, z: 0 };
            // Project Spine Start
            let ssx = spineStart.x * Math.cos(angleY) - spineStart.z * Math.sin(angleY); // 0
            let ssz = spineStart.z * Math.cos(angleY) + spineStart.x * Math.sin(angleY); // 0
            let ssy = spineStart.y; // -200
            let scaleS = 600 / (600 + ssz + 400);
            let screenSX = ssy * scaleS + cx;
            let screenSY = ssx * scaleS + cy;
            
            // Project Spine End
            let esx = spineEnd.x * Math.cos(angleY) - spineEnd.z * Math.sin(angleY);
            let esz = spineEnd.z * Math.cos(angleY) + spineEnd.x * Math.sin(angleY);
            let esy = spineEnd.y;
            let scaleE = 600 / (600 + esz + 400);
            let screenEX = esy * scaleE + cx;
            let screenEY = esx * scaleE + cy;

            ctx.strokeStyle = "rgba(0, 255, 255, 0.3)";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(screenSX, screenSY);
            ctx.lineTo(screenEX, screenEY);
            ctx.stroke();

            // 2. Draw Connections (Node to Spine)
            ctx.lineWidth = 1;
            points.forEach(p => {
                // Calculate spine point at this node's Y
                let spy = p.data.y;
                let spx = 0; 
                let spz = 0;
                // Project Spine point
                let rx = spx * Math.cos(angleY) - spz * Math.sin(angleY);
                let rz = spz * Math.cos(angleY) + spx * Math.sin(angleY);
                let s = 600 / (600 + rz + 400);
                let sx = spy * s + cx;
                let sy = rx * s + cy;

                ctx.strokeStyle = `rgba(255, 255, 255, 0.2)`;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(p.sx, p.sy);
                ctx.stroke();
            });

            // 3. Draw Nodes
            points.forEach(p => p.draw(ctx));

            // 4. Draw Flow Particles
            const time = Date.now() * 0.001;
            ctx.globalCompositeOperation = 'lighter';
            flowParticles.forEach(p => {
                // Update Pos
                let speed = p.speed * (1 + (cfRatio - 0.5)); // C:F influence
                p.y += speed;
                
                // Logic: Pause at DB (Stomach)
                if(p.y > -20 && p.y < 20) {
                    p.y += speed * 0.5; // Slow down at DB
                    // Expand radius
                    var r = 20;
                } else {
                    var r = 5;
                }
                
                let x = Math.cos(time*5 + p.offset) * r;
                let z = Math.sin(time*5 + p.offset) * r;

                if (p.y > 180) p.y = -200; // Reset

                // Project
                let rx = x * Math.cos(angleY) - z * Math.sin(angleY);
                let rz = z * Math.cos(angleY) + x * Math.sin(angleY);
                let scale = 600 / (600 + rz + 400);
                let sx = p.y * scale + cx;
                let sy = rx * scale + cy;

                // Color based on position (Cyan -> Purple -> White)
                let col = "255, 255, 255";
                if(p.y < -50) col = "0, 255, 255"; // Input/OS
                else if(p.y < 30) col = "255, 100, 0"; // DB
                else col = "200, 0, 255"; // Factor

                ctx.fillStyle = `rgba(${col}, 0.8)`;
                ctx.beginPath();
                ctx.arc(sx, sy, 3 * scale, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalCompositeOperation = 'source-over';

            // 5. Draw Diagram Labels
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.font = "12px Consolas";
            ctx.textAlign = "left";
            
            LABELS.forEach(l => {
                // Project label pos (Fixed X offset from spine)
                let spy = l.y;
                let spx = 0; let spz = 0;
                let rz = spz * Math.cos(angleY) + spx * Math.sin(angleY);
                let s = 600 / (600 + rz + 400);
                let sx = spy * s + cx;
                let sy = 0 * s + cy; // Center line
                
                // Draw Label Text
                ctx.fillText(l.text, sx + 120 * s, sy - 50 * s);
                // Line
                ctx.strokeStyle = "rgba(0,255,255,0.3)";
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(sx + 110*s, sy - 50*s);
                ctx.stroke();
            });

            requestAnimationFrame(animate);
        }

        // --- EVENTS ---
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        window.addEventListener('mousedown', e => {
            if(e.target.closest('#panel') || e.target.closest('#cf-container')) return;
            
            // Hit Test
            let hit = false;
            // Sort by depth for click
            const sorted = [...points].sort((a,b) => a.zIndex - b.zIndex); 
            
            for(let p of sorted) {
                const dx = e.clientX - p.sx;
                const dy = e.clientY - p.sy;
                if(Math.sqrt(dx*dx + dy*dy) < 20 * p.scale) {
                    showPanel(p.data);
                    hit = true;
                    isDragging = false;
                    break;
                }
            }
            if(!hit) {
                isDragging = true;
                lastMouseX = e.clientX;
                closePanel();
            }
        });

        window.addEventListener('mousemove', e => {
            if(isDragging) {
                const delta = e.clientX - lastMouseX;
                angleY += delta * 0.01;
                lastMouseX = e.clientX;
            }
            // Cursor
            let hit = false;
            for(let p of points) {
                const dx = e.clientX - p.sx;
                const dy = e.clientY - p.sy;
                if(Math.sqrt(dx*dx + dy*dy) < 20 * p.scale) hit = true;
            }
            document.body.style.cursor = hit ? 'pointer' : 'default';
        });

        window.addEventListener('mouseup', () => isDragging = false);

        // C:F Slider Logic
        const track = document.getElementById('cf-track');
        const knob = document.getElementById('cf-knob');
        let isSliding = false;

        track.addEventListener('mousedown', e => { isSliding = true; updateSlider(e); });
        window.addEventListener('mousemove', e => { if(isSliding) updateSlider(e); });
        window.addEventListener('mouseup', () => isSliding = false);

        function updateSlider(e) {
            const rect = track.getBoundingClientRect();
            let x = e.clientX - rect.left;
            x = Math.max(0, Math.min(x, rect.width));
            cfRatio = x / rect.width;
            knob.style.left = (cfRatio * 100) + '%';
        }

        function showPanel(d) {
            document.getElementById('p-tag').innerText = d.type;
            document.getElementById('p-tag').style.background = d.color;
            document.getElementById('p-title').innerText = d.name;
            document.getElementById('p-title').style.color = d.color;
            document.getElementById('p-desc').innerText = d.desc;
            document.getElementById('p-role').innerText = d.role;
            document.getElementById('p-thought').innerText = d.thought;
            document.getElementById('panel').classList.add('active');
        }
        function closePanel() {
            document.getElementById('panel').classList.remove('active');
        }
        window.closePanel = closePanel;

        function startApp() {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => { document.getElementById('loader').style.display='none'; }, 500);
        }
        window.startApp = startApp;

        // Init
        init();

    </script>
</body>
</html>
